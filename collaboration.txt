Michael Lopez & Christian Rotondo
Prof. King
April 16th, 2025
CSCI 324

Annotated Bibliography:
Works Cited
Blandy, Jim, and Jason Orendorff. Programming Rust. “O’Reilly Media, Inc.,” 21 Nov. 2017.
This more advanced text complemented our understanding of Rust’s concurrency model by diving deeper into low-level details like mutexes, atomic operations, and memory safety. It directly influenced our implementation of Arc<Mutex<>> patterns for topic management, ensuring that multiple threads could safely modify shared data structures. The book’s in-depth technical focus made it invaluable when addressing race conditions and deadlocks. While it’s highly technical and not as beginner-friendly, its detailed treatment of concurrency is what made it a critical resource during implementation.
“Char - Rust.” Rust-Lang.org, 2025, doc.rust-lang.org/std/primitive.char.html. Accessed 15 Apr. 2025.
This documentation was crucial when implementing our message parsing logic in the Consumer::parse_message() method. We relied on it to understand character-level manipulation and ensure that we handled message delimiters correctly. Its straightforward and well-organized presentation made it easy to reference during development. While limited in scope, it served its purpose well for our string-parsing needs.
“Closures - Rust by Example.” Doc.rust-Lang.org, doc.rust-lang.org/rust-by-example/fn/closures.html.
This section provided the foundation for our use of closures, especially in cases like lazy initialization of topics using or_insert_with() in broker.rs. The documentation’s practical focus helped us understand how closures capture variables and how they can be used effectively in collection manipulation. Though brief, it was highly effective for introducing closures and applying them in context. Its brevity, however, limits its usefulness for more complex closure use cases.
“Env_logger - Rust.” Docs.rs, 2017, docs.rs/env_logger/latest/env_logger/.
This logging companion crate allowed us to initialize the log crate via environment variables, enabling dynamic verbosity during development and testing. Its plug-and-play integration made logging setup painless. The documentation was brief but direct, and perfectly sufficient for its purpose. Its main limitation is a lack of customization features, but it fulfilled all our needs for basic runtime logging.
“Introduction - Rust by Example.” Doc.rust-Lang.org, doc.rust-lang.org/rust-by-example/.
This hands-on guide offered concise, runnable examples that guided the design of our initial broker logic and error-handling structure. We referred to it extensively while prototyping main.rs and defining basic control flow with match and Result. The documentation’s concise format makes it easy to consult for quick syntax checks or implementation ideas. However, its modular format can feel disjointed when trying to understand a complete application flow, which limited its usefulness for architectural decisions.
“Iterator in Std::Iter - Rust.” Rust-Lang.org, 2025, doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each. Accessed 15 Apr. 2025.
This reference introduced us to efficient message filtering using iterator combinators like filter, map, and collect. We applied these concepts in Topic::consume() to retrieve messages newer than a client’s offset. The documentation is concise and code-oriented, making it easy to apply concepts immediately. However, its example-based style assumes prior familiarity with traits, which can be a barrier for less experienced developers. Overall, it provided us with the tools needed to implement message streaming in an idiomatic and performant way.
Klabnik, Steve, and Carol Nichols. The Rust Programming Language : Covers Rust 2018. San Francisco, CA, No Starch Press, 2019.
This book served as our foundational resource for understanding Rust’s unique ownership model, concurrency, and safety guarantees. It was especially helpful in designing thread-safe communication between producer, broker, and consumer modules by explaining how Rust enforces safe data access through borrowing and ownership. The book’s clear explanations and practical examples were essential in structuring our multi-threaded broker system. Its strength lies in its clarity and broad scope, making it ideal for beginners and intermediate Rust users. However, it lacks in-depth coverage of real-world networking applications, which we had to explore elsewhere.
“Log - Rust.” Docs.rs, 2025, docs.rs/log/latest/log/. Accessed 15 Apr. 2025.
This crate formed the backbone of our internal logging strategy. We used info!, warn!, and error! macros across the broker to trace runtime behavior and debug issues. The crate’s flexibility in decoupling logging backends from application logic made it easy to maintain and scale. Its documentation was clear and easy to integrate with other crates, making it one of the most useful external resources in our project. A potential drawback is the lack of built-in formatting templates, which required us to manually structure log outputs.
“Open - Rust by Example.” Rust-Lang.org, 2024, doc.rust-lang.org/rust-by-example/std_misc/file/open.html.
This guide was helpful during early experiments with file I/O, particularly when testing data persistence before switching fully to socket-based communication. It provided reliable examples for handling Result and reading from files. The documentation is effective for simple use cases but not comprehensive enough for designing a complete logging or configuration system. Nonetheless, it served as a useful reference during early development.
“Rand - Rust.” Docs.rs, docs.rs/rand/latest/rand/.
We used this library during testing to generate random payloads and simulate varying message patterns. While it was not included in the final version of the system, it played a key role in stress-testing components like publish() and consume(). The documentation is well-maintained, offering clear examples. However, because of the randomness involved, it lacked deterministic reproducibility for debugging.
“Recoverable Errors with Result - the Rust Programming Language.” Doc.rust-Lang.org, doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html.
This section helped shape our use of the Result enum for robust error propagation in client and broker communication. It reinforced best practices for returning recoverable errors rather than panicking, which improved the broker's reliability. We structured our error returns in both producer.rs and consumer.rs to match the idioms explained here. Its focused, practical tone and real-world relevance made it an especially strong part of the official documentation. The only downside is its lack of depth when handling complex or nested error types, which we had to explore further.
Simi, Fachtna. “How to Access the Peer IP Address in Tokio-Tungstenite 0.10?” Stack Overflow, 21 July 2020, stackoverflow.com/questions/63024046/how-to-access-the-peer-ip-address-in-tokio-tungstenite-0-10.
This Stack Overflow thread directly informed our method for retrieving the client's IP address within the handle_client() function. The accepted answer gave us a practical snippet that allowed us to log and track client connections based on their socket metadata. This source was incredibly helpful in solving a very specific challenge that was not clearly documented in the official tokio-tungstenite docs. While community-sourced and sometimes inconsistent in quality, this particular solution was well-explained and immediately applicable.
